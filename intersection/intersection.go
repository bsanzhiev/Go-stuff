package main

// На вход подаются два неупорядоченных слайса любой длины. Надо написать 
// функцию, которая возвращает их пересечение

// Можно решить сортировкой, за более долгое время, но без выделения дополнительной памяти. 
// А можно выделить дополнительную память и решить за линейное время.

// Надо посчитать количество появлений элементов первого массива 
// (лучше брать тот, что покороче) — используем для этого словарь. 
// Потом пройтись по второму массиву и вычитать из словаря те элементы,
// которые есть в нем. По ходу добавляем в результат те элементы, у которых
// частота появлений больше нуля.

import "fmt"

func intersection(a, b []int) []int {
  // создаем словарь, в котором будем хранить количество появлений элем
  // в первом массиве
  counter := make(map[int]int)
  // слайс для результата
  var result []int
  // добавляем в словарь количество появлений элементов первого
  // массива
  for _, elem := range a {
    counter[elem]++
  }
  // проходим по второму массиву и вычитаем из словаря те
  // элементы, которые есть в нем
  for _, elem := range b {
    if count, ok := counter[elem]; ok && count > 0 {
      counter[elem]--
      result = append(result, elem)
    }
  }
  return result
}

func main() {
  a := []int{1, 2, 3, 4, 5}
  b := []int{1, 2, 4, 5, 6, 7, 8, 9, 10}
  fmt.Printf("%v\n", intersection(a, b))
  a = []int{1, 1, 1}
  b = []int{1, 1, 1, 1}
  fmt.Printf("%v\n", intersection(a, b))
}
